<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoL Yeteneklerinden KaÃ§Ä±ÅŸ Oyunu (MÃ¼kemmel V2)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap');

        body {
            background: linear-gradient(135deg, #0a111a 0%, #0d1726 100%);
            color: #ecf0f1;
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 40px rgba(88, 166, 255, 0.6);
            border-radius: 16px;
            overflow: hidden;
            transform: scale(1);
            transition: transform 0.2s ease;
        }

        #screen-shake {
            width: 100%;
            height: 100%;
            transition: transform 0.05s ease-out;
        }
        
        #hit-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0);
            z-index: 5;
            pointer-events: none;
            transition: background-color 0.1s ease-out;
        }

        canvas {
            background: linear-gradient(to bottom, #161b22, #1f2a38);
            display: block;
            border-radius: 16px;
        }
        
        .info-panel {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #8b949e;
            text-shadow: 0 0 5px rgba(88, 166, 255, 0.3);
            z-index: 2;
        }

        .dash-panel {
            position: absolute;
            bottom: 15px;
            left: 15px;
            width: 150px;
            height: 20px;
            background-color: #333;
            border: 1px solid #58a6ff;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .dash-cooldown {
            height: 100%;
            background-color: #58a6ff;
            transition: width 0.1s linear;
        }
        
        .dash-panel span {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8em;
            color: white;
            z-index: 2;
        }

        .game-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            border-radius: 16px;
        }
        
        .game-screen.active {
            opacity: 1;
            pointer-events: all;
        }

        .game-screen h2 {
            font-size: 3em;
            color: #58a6ff;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #58a6ff;
        }

        .game-screen p {
            font-size: 1.5em;
            color: #ecf0f1;
            margin: 5px 0;
        }

        .game-screen button {
            background-color: #58a6ff;
            color: #0c0e12;
            border: none;
            padding: 18px 36px;
            font-size: 1.3em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 10px;
            margin-top: 40px;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            box-shadow: 0 6px 15px rgba(88, 166, 255, 0.4);
        }

        .game-screen button:hover {
            background-color: #79c0ff;
            box-shadow: 0 8px 20px rgba(88, 166, 255, 0.6);
            transform: translateY(-2px);
        }

        .game-screen button:active {
            transform: scale(0.96);
            box-shadow: 0 4px 10px rgba(88, 166, 255, 0.4);
        }

        .health-bar-container {
            width: 120px;
            height: 12px;
            background-color: #333;
            border: 1px solid #58a6ff;
            border-radius: 5px;
            overflow: hidden;
        }

        .health-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #2ecc71, #f1c40f, #e74c3c);
            transition: width 0.3s ease-in-out, background 0.3s ease-in-out;
            transform-origin: left;
        }

        .active-powers {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
        }
        
        .power-icon {
            font-size: 2em;
            position: relative;
            cursor: default;
            user-select: none;
        }
        
        .power-timer {
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 2px 5px;
            border-radius: 4px;
            color: white;
            white-space: nowrap;
        }
        
        #boss-health-container {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            border-color: #e74c3c;
            display: none;
            z-index: 2;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="screen-shake">
            <div id="hit-flash"></div>
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>
        
        <div id="start-screen" class="game-screen active">
            <h2>Yeteneklerden KaÃ§Ä±ÅŸ</h2>
            <p>WASD ile hareket et, Space ile Ä±ÅŸÄ±nlan, **farenle ateÅŸ et!**</p>
            <button id="startButton">OYNA</button>
        </div>

        <div id="game-over-screen" class="game-screen">
            <h2>Oyun Bitti!</h2>
            <p>Son Skorun: <span id="finalScore">0</span></p>
            <p>Hayatta Kalma SÃ¼ren: <span id="finalTime">0</span> saniye</p>
            <button id="restartButton">TEKRAR OYNA</button>
        </div>

        <div id="boss-health-container" class="health-bar-container">
            <div id="boss-health-bar" class="health-bar" style="background: #e74c3c;"></div>
        </div>

        <div class="info-panel">
            <span>Skor: <span id="score">0</span></span>
            <div class="health-bar-container">
                <div id="healthBar" class="health-bar"></div>
            </div>
            <span>SÃ¼re: <span id="time">0</span>s</span>
        </div>
        
        <div class="dash-panel">
            <div id="dashCooldownBar" class="dash-cooldown"></div>
            <span>IÅžINLAN (SPACE)</span>
        </div>

        <div class="active-powers" id="activePowersContainer"></div>
    </div>

    <script>
        // --- Game Objects Classes (Moved outside the Game class) ---
        class Player {
            constructor(game, x, y, size, speed) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.size = size;
                this.speed = speed;
                this.dx = 0;
                this.dy = 0;
                this.health = 100;
                this.projectileCooldown = 500;
                this.lastShotTime = 0;
            }
            draw() {
                const ctx = this.game.ctx;
                ctx.font = `${this.size * 2}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = '#f0f6fc';
                ctx.shadowBlur = 15;
                ctx.fillText('â­', this.x, this.y);
                ctx.shadowBlur = 0;

                const shieldPowerUp = this.game.activePowerUps.find(p => p.type === 'shield');
                if (shieldPowerUp) {
                    const progress = (shieldPowerUp.endTime - Date.now()) / shieldPowerUp.duration;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.4 + 0.4 * progress})`;
                    ctx.lineWidth = 5;
                    ctx.stroke();
                }
            }
            update(deltaTime) {
                this.x += this.dx * this.speed * deltaTime;
                this.y += this.dy * this.speed * deltaTime;

                if (this.x < this.size) this.x = this.size;
                if (this.x > this.game.canvas.width - this.size) this.x = this.game.canvas.width - this.size;
                if (this.y < this.size) this.y = this.size;
                if (this.y > this.game.canvas.height - this.size) this.y = this.game.canvas.height - this.size;
            }
            shoot() {
                if (Date.now() - this.lastShotTime > this.projectileCooldown) {
                    this.game.playerProjectiles.push(new PlayerProjectile(this.game, this.x, this.y));
                    this.game.playSound(900, 0.1, 0.6);
                    this.lastShotTime = Date.now();
                }
            }
        }

        class PlayerProjectile {
            constructor(game, x, y) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.size = 10;
                this.speed = 10;
                this.emoji = 'ðŸš€';
            }
            draw() {
                const ctx = this.game.ctx;
                ctx.font = `${this.size * 2}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 10;
                ctx.fillText(this.emoji, this.x, this.y);
                ctx.shadowBlur = 0;
            }
            update(deltaTime) {
                this.y -= this.speed * deltaTime;
                return this.y > -this.size;
            }
        }

        class Projectile {
            constructor(game, x, y, data) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.size = data.size;
                this.speed = data.speed;
                this.color = data.color;
                this.emoji = data.emoji;
                this.damage = data.damage;
                this.type = data.type;
                this.aoeDuration = data.aoeDuration || 0;
                this.creationTime = Date.now();
            }
            draw() {
                const ctx = this.game.ctx;
                ctx.font = `${this.size * 2}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fillText(this.emoji, this.x, this.y);
                ctx.shadowBlur = 0;
            }
            update(deltaTime) {
                const isSlowed = this.game.activePowerUps.some(p => p.type === 'slow');
                const isFrozen = this.game.activePowerUps.some(p => p.type === 'freeze');
                const currentSpeed = isSlowed ? this.speed * 0.5 : this.speed;
                
                if (isFrozen) {
                    return true;
                }

                if (this.type === "linear") {
                    this.y += currentSpeed * deltaTime;
                } else if (this.type === "homing") {
                    const angle = Math.atan2(this.game.player.y - this.y, this.game.player.x - this.x);
                    this.x += currentSpeed * Math.cos(angle) * deltaTime;
                    this.y += currentSpeed * Math.sin(angle) * deltaTime;
                } else if (this.type === "aoe") {
                    const elapsed = Date.now() - this.creationTime;
                    if (elapsed >= this.aoeDuration) {
                        return false;
                    }
                }
                return true;
            }
        }

        class Boss {
            constructor(game, x, y, size, health, speed) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.size = size;
                this.health = health;
                this.maxHealth = health;
                this.speed = speed;
                this.projectileCooldown = 1000;
                this.lastProjectileTime = 0;
            }
            draw() {
                const ctx = this.game.ctx;
                ctx.font = `${this.size * 2}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = '#e74c3c';
                ctx.shadowBlur = 20;
                ctx.fillText('ðŸ‘¹', this.x, this.y);
                ctx.shadowBlur = 0;
            }
            update(deltaTime) {
                const angle = Math.atan2(this.game.player.y - this.y, this.game.player.x - this.x);
                this.x += this.speed * Math.cos(angle) * deltaTime;
                this.y += this.speed * Math.sin(angle) * deltaTime;

                if (Date.now() - this.lastProjectileTime > this.projectileCooldown) {
                    this.shoot();
                    this.lastProjectileTime = Date.now();
                }
            }
            shoot() {
                const homingProjectileData = this.game.projectileData.find(p => p.type === 'homing');
                this.game.projectiles.push(new Projectile(this.game, this.x, this.y, homingProjectileData));
                this.game.playSound(200, 0.1, 0.5, 'square');
            }
        }

        class Collectable {
            constructor(game, x, y, data) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.size = data.size;
                this.color = data.color;
                this.emoji = data.emoji;
                this.type = data.type;
                this.value = data.value || 0;
                this.duration = data.duration || 0;
            }
            draw() {
                const ctx = this.game.ctx;
                ctx.font = `${this.size * 2}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fillText(this.emoji, this.x, this.y);
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(game, x, y, color) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 2 + 1;
                this.color = color;
                this.velocity = {
                    x: (Math.random() - 0.5) * 5,
                    y: (Math.random() - 0.5) * 5
                };
                this.alpha = 1;
                this.friction = 0.98;
            }
            draw() {
                const ctx = this.game.ctx;
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            update(deltaTime) {
                this.velocity.x *= this.friction;
                this.velocity.y *= this.friction;
                this.x += this.velocity.x * deltaTime * 60;
                this.y += this.velocity.y * deltaTime * 60;
                this.alpha -= 0.02;
                return this.alpha > 0;
            }
        }

        class Star {
            constructor(game) {
                this.game = game;
                this.x = Math.random() * this.game.canvas.width;
                this.y = Math.random() * this.game.canvas.height;
                this.radius = Math.random() * 1.5;
                this.velocity = Math.random() * 0.5 + 0.1;
                this.color = `rgba(255, 255, 255, ${Math.random() * 0.8 + 0.2})`;
            }
            draw() {
                const ctx = this.game.ctx;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
            update(deltaTime) {
                this.y += this.velocity * deltaTime * 60;
                if (this.y > this.game.canvas.height) {
                    this.y = 0;
                    this.x = Math.random() * this.game.canvas.width;
                }
            }
        }

        class Game {
            constructor() {
                // Game elements
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.screenShakeContainer = document.getElementById('screen-shake');
                this.hitFlash = document.getElementById('hit-flash');
                this.startScreen = document.getElementById('start-screen');
                this.gameOverScreen = document.getElementById('game-over-screen');
                this.startButton = document.getElementById('startButton');
                this.restartButton = document.getElementById('restartButton');
                this.scoreElement = document.getElementById('score');
                this.healthBarElement = document.getElementById('healthBar');
                this.timeElement = document.getElementById('time');
                this.finalScoreElement = document.getElementById('finalScore');
                this.finalTimeElement = document.getElementById('finalTime');
                this.dashCooldownBarElement = document.getElementById('dashCooldownBar');
                this.bossHealthContainer = document.getElementById('boss-health-container');
                this.bossHealthBarElement = document.getElementById('boss-health-bar');
                this.activePowersContainer = document.getElementById('activePowersContainer');

                // Game state
                this.player = null;
                this.projectiles = [];
                this.playerProjectiles = [];
                this.stars = [];
                this.particles = [];
                this.collectables = [];
                this.keys = {};
                this.score = 0;
                this.time = 0;
                this.difficulty = 1;
                this.isGameOver = true;
                this.isShaking = false;
                this.activePowerUps = [];
                this.dashReady = true;
                this.dashCooldown = 2000;
                this.lastDashTime = 0;
                this.boss = null;
                this.isBossFight = false;
                this.lastUpdateTime = performance.now();
                this.gameLoopInterval = null;

                // Game constants
                this.BOSS_SPAWN_TIME = 60;
                this.BOSS_HEALTH = 1000;
                this.projectileData = [
                    { name: "Mavi Yetenek", color: "#58a6ff", emoji: "ðŸ’ ", size: 20, speed: 3, damage: 10, type: "linear" },
                    { name: "Turuncu Yetenek", color: "#f7961b", emoji: "ðŸŸ ", size: 15, speed: 4.5, damage: 15, type: "homing" },
                    { name: "Mor Yetenek", color: "#a371f7", emoji: "ðŸ”®", size: 35, speed: 0, damage: 20, type: "aoe", aoeDuration: 2000 },
                    { name: "HÄ±z KÃ¼resi", color: "#e74c3c", emoji: "ðŸ”´", size: 10, speed: 8, damage: 5, type: "linear" }
                ];
                this.collectableData = [
                    { name: "Can Paketi", color: "#2ecc71", emoji: "ðŸŸ¢", size: 12, type: "health", value: 30 },
                    { name: "Kalkan", color: "#ffd700", emoji: "ðŸŸ¡", size: 12, type: "shield", duration: 5000 },
                    { name: "Zaman KÃ¼resi", color: "#00bfff", emoji: "ðŸ”µ", size: 12, type: "slow", duration: 3000 },
                    { name: "Puan Ã‡arpanÄ±", color: "#e67e22", emoji: "ðŸ’²", size: 12, type: "multiplier", duration: 10000, value: 2 },
                    { name: "Dondurma KÃ¼resi", color: "#3498db", emoji: "ðŸ§Š", size: 12, type: "freeze", duration: 3000 },
                    { name: "Bomba", color: "#c0392b", emoji: "ðŸ’¥", size: 15, type: "bomb" }
                ];

                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                this.initEventListeners();
            }

            initEventListeners() {
                document.addEventListener('keydown', (e) => { this.keys[e.key.toLowerCase()] = true; });
                document.addEventListener('keyup', (e) => { this.keys[e.key.toLowerCase()] = false; });
                this.startButton.addEventListener('click', () => this.startGame());
                this.restartButton.addEventListener('click', () => this.startGame());
                this.canvas.addEventListener('click', () => { if (!this.isGameOver) this.player.shoot(); });
            }

            playSound(frequency, duration, volume, type = 'sine') {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            shakeScreen() {
                if (this.isShaking) return;
                this.isShaking = true;
                let shakeDuration = 200;
                let shakeIntensity = 5;
                let startTime = Date.now();
                const doShake = () => {
                    const elapsed = Date.now() - startTime;
                    if (elapsed > shakeDuration) {
                        this.screenShakeContainer.style.transform = `translate(0px, 0px)`;
                        this.isShaking = false;
                        return;
                    }
                    const x = Math.random() * shakeIntensity * 2 - shakeIntensity;
                    const y = Math.random() * shakeIntensity * 2 - shakeIntensity;
                    this.screenShakeContainer.style.transform = `translate(${x}px, ${y}px)`;
                    requestAnimationFrame(doShake);
                };
                doShake();
            }

            flashHit() {
                this.hitFlash.style.backgroundColor = 'rgba(255, 0, 0, 0.4)';
                setTimeout(() => {
                    this.hitFlash.style.backgroundColor = 'rgba(255, 0, 0, 0)';
                }, 100);
            }
            
            // --- Game Logic ---
            startGame() {
                this.isGameOver = false;
                this.score = 0;
                this.time = 0;
                this.difficulty = 1;
                this.player = new Player(this, this.canvas.width / 2, this.canvas.height - 50, 15, 6);
                this.projectiles = [];
                this.playerProjectiles = [];
                this.particles = [];
                this.collectables = [];
                this.activePowerUps = [];
                this.dashReady = true;
                this.boss = null;
                this.isBossFight = false;
                this.lastUpdateTime = performance.now();
                
                this.updateHealthBar();
                this.scoreElement.textContent = this.score;
                this.timeElement.textContent = this.time;
                this.startScreen.classList.remove('active');
                this.gameOverScreen.classList.remove('active');
                this.bossHealthContainer.style.display = 'none';
                this.initStars();

                if (!this.gameLoopInterval) {
                    this.gameLoop();
                }
            }

            gameOver() {
                this.isGameOver = true;
                this.gameOverScreen.classList.add('active');
                this.finalScoreElement.textContent = this.score;
                this.finalTimeElement.textContent = this.time;
                this.playSound(100, 0.5, 0.7);
                cancelAnimationFrame(this.gameLoopInterval);
                this.gameLoopInterval = null;
            }

            gameLoop() {
                if (this.isGameOver) return;
                const now = performance.now();
                const deltaTime = (now - this.lastUpdateTime) / 1000;
                this.lastUpdateTime = now;

                const isSlowed = (this.activePowerUps || []).some(p => p.type === 'slow');
                const isMultiplied = (this.activePowerUps || []).some(p => p.type === 'multiplier');
                const gameSpeed = isSlowed ? 0.5 : 1;

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.stars.forEach(star => {
                    star.update(deltaTime * gameSpeed);
                    star.draw();
                });
                
                this.handleInput();
                this.player.update(deltaTime * 60 * gameSpeed);
                this.updateDashCooldown();
                this.updatePowerUpUI();
                this.createPlayerParticles();

                this.playerProjectiles = (this.playerProjectiles || []).filter(p => p.update(deltaTime * 60 * gameSpeed));
                this.playerProjectiles.forEach(p => p.draw());

                if (!this.isBossFight) {
                    this.projectiles = (this.projectiles || []).filter(p => p.update(deltaTime * 60 * gameSpeed) && (p.y < this.canvas.height + p.size));
                    
                    const spawnRate = 0.02 + this.difficulty * 0.002;
                    if (Math.random() < spawnRate) {
                        this.createProjectile();
                    }

                    if (Math.random() < 0.001) {
                        this.createCollectable();
                    }
                } else {
                    this.boss.update(deltaTime * 60 * gameSpeed);
                    this.boss.draw();
                }

                (this.projectiles || []).forEach(p => p.draw());
                this.collectables = (this.collectables || []).filter(c => c.y < this.canvas.height + c.size);
                (this.collectables || []).forEach(c => c.draw());
                
                this.particles = (this.particles || []).filter(p => p.update(deltaTime * 60 * gameSpeed));
                (this.particles || []).forEach(p => p.draw());

                this.playerParticles = (this.playerParticles || []).filter(p => p.update(deltaTime * 60 * gameSpeed));
                (this.playerParticles || []).forEach(p => p.draw());

                this.checkCollision();
                this.player.draw();

                if (!this.isBossFight) {
                    const scoreMultiplier = isMultiplied ? 2 : 1;
                    this.score += scoreMultiplier;
                }
                this.time = Math.floor(this.score / 60);
                this.difficulty = Math.floor(this.time / 20);
                this.scoreElement.textContent = this.score;
                this.timeElement.textContent = this.time;
                
                if (this.time >= this.BOSS_SPAWN_TIME && !this.isBossFight && this.boss === null) {
                    this.spawnBoss();
                }

                if (this.player.health > 0) {
                    this.gameLoopInterval = requestAnimationFrame(() => this.gameLoop());
                } else {
                    this.gameOver();
                }
            }
            
            // --- Helper Methods ---
            initStars() {
                this.stars = [];
                for (let i = 0; i < 100; i++) {
                    this.stars.push(new Star(this));
                }
            }

            handleInput() {
                this.player.dx = 0;
                this.player.dy = 0;

                if (this.keys['w'] || this.keys['W']) this.player.dy = -1;
                if (this.keys['s'] || this.keys['S']) this.player.dy = 1;
                if (this.keys['a'] || this.keys['A']) this.player.dx = -1;
                if (this.keys['d'] || this.keys['D']) this.player.dx = 1;

                if (this.player.dx !== 0 && this.player.dy !== 0) {
                    const angle = Math.atan2(this.player.dy, this.player.dx);
                    this.player.dx = Math.cos(angle);
                    this.player.dy = Math.sin(angle);
                }
                
                if (this.keys[' '] && this.dashReady) {
                    const dashDistance = 100;
                    this.player.x += this.player.dx * dashDistance;
                    this.player.y += this.player.dy * dashDistance;
                    
                    this.lastDashTime = Date.now();
                    this.dashReady = false;
                    this.playSound(800, 0.1, 0.7);
                }
            }
            
            updateDashCooldown() {
                const timeSinceDash = Date.now() - this.lastDashTime;
                if (timeSinceDash >= this.dashCooldown) {
                    this.dashReady = true;
                    this.dashCooldownBarElement.style.width = '100%';
                } else {
                    const cooldownPercentage = (timeSinceDash / this.dashCooldown) * 100;
                    this.dashCooldownBarElement.style.width = `${cooldownPercentage}%`;
                }
            }

            updatePowerUpUI() {
                this.activePowersContainer.innerHTML = '';
                const now = Date.now();
                this.activePowerUps = (this.activePowerUps || []).filter(p => now < p.endTime);
                
                this.activePowerUps.forEach(power => {
                    const powerEl = document.createElement('div');
                    powerEl.className = 'power-icon';
                    powerEl.textContent = power.emoji;
                    
                    const timerEl = document.createElement('span');
                    timerEl.className = 'power-timer';
                    const remainingTime = ((power.endTime - now) / 1000).toFixed(1);
                    timerEl.textContent = `${remainingTime}s`;
                    
                    powerEl.appendChild(timerEl);
                    this.activePowersContainer.appendChild(powerEl);
                });
            }

            checkCollision() {
                const isShielded = (this.activePowerUps || []).some(p => p.type === 'shield');
                
                // Player projectiles vs enemy projectiles/boss
                for (let i = (this.playerProjectiles || []).length - 1; i >= 0; i--) {
                    const p = this.playerProjectiles[i];
                    
                    if (this.boss) {
                        const distanceToBoss = Math.sqrt(Math.pow(p.x - this.boss.x, 2) + Math.pow(p.y - this.boss.y, 2));
                        if (distanceToBoss < p.size + this.boss.size) {
                            this.boss.health -= 50;
                            this.updateBossHealthBar();
                            this.playerProjectiles.splice(i, 1);
                            this.playSound(350, 0.1, 0.7);
                            if (this.boss.health <= 0) {
                                this.destroyBoss();
                            }
                            continue;
                        }
                    }

                    for (let j = (this.projectiles || []).length - 1; j >= 0; j--) {
                        const e = this.projectiles[j];
                        const distance = Math.sqrt(Math.pow(p.x - e.x, 2) + Math.pow(p.y - e.y, 2));
                        if (distance < p.size + e.size) {
                            for (let k = 0; k < 5; k++) {
                                this.particles.push(new Particle(this, e.x, e.y, e.color));
                            }
                            this.projectiles.splice(j, 1);
                            this.playerProjectiles.splice(i, 1);
                            this.playSound(500, 0.1, 0.5);
                            break;
                        }
                    }
                }
                
                // Player vs enemy projectiles
                for (let i = (this.projectiles || []).length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    const distance = Math.sqrt(Math.pow(this.player.x - p.x, 2) + Math.pow(this.player.y - p.y, 2));
                    
                    if (distance < this.player.size + p.size) {
                        if (!isShielded) {
                            for (let j = 0; j < 10; j++) {
                                this.particles.push(new Particle(this, p.x, p.y, p.color));
                            }
                            this.shakeScreen();
                            this.flashHit();
                            this.player.health -= p.damage;
                            this.updateHealthBar();
                            if (this.player.health > 0) {
                                this.playSound(300, 0.1, 0.5);
                            }
                        } else {
                             this.playSound(600, 0.1, 0.5);
                        }
                        this.projectiles.splice(i, 1);
                        if (this.player.health <= 0) {
                            this.gameOver();
                        }
                    }
                }
                
                // Player vs boss
                if (this.boss) {
                    const bossDistance = Math.sqrt(Math.pow(this.player.x - this.boss.x, 2) + Math.pow(this.player.y - this.boss.y, 2));
                    if (bossDistance < this.player.size + this.boss.size) {
                        this.player.health = 0;
                        this.gameOver();
                    }
                }

                // Player vs collectables
                for (let i = (this.collectables || []).length - 1; i >= 0; i--) {
                    const c = this.collectables[i];
                    const distance = Math.sqrt(Math.pow(this.player.x - c.x, 2) + Math.pow(this.player.y - c.y, 2));

                    if (distance < this.player.size + c.size) {
                        for (let j = 0; j < 10; j++) {
                            this.particles.push(new Particle(this, c.x, c.y, c.color));
                        }
                        this.playSound(450, 0.1, 0.5);
                        
                        if (c.type === "health") {
                            this.player.health = Math.min(100, this.player.health + c.value);
                            this.updateHealthBar();
                        } else if (c.type === "bomb") {
                            this.projectiles = [];
                            this.playSound(100, 0.5, 0.7, 'square');
                        } else {
                            const existingPower = this.activePowerUps.find(p => p.type === c.type);
                            if (existingPower) {
                                existingPower.endTime = Date.now() + c.duration;
                            } else {
                                this.activePowerUps.push({
                                    type: c.type,
                                    endTime: Date.now() + c.duration,
                                    emoji: c.emoji,
                                    duration: c.duration
                                });
                            }
                        }
                        this.collectables.splice(i, 1);
                    }
                }
            }
            
            updateHealthBar() {
                const healthPercentage = this.player.health > 0 ? this.player.health : 0;
                this.healthBarElement.style.width = healthPercentage + '%';
                
                if (healthPercentage > 75) {
                    this.healthBarElement.style.background = '#2ecc71';
                } else if (healthPercentage > 25) {
                    this.healthBarElement.style.background = '#f1c40f';
                } else {
                    this.healthBarElement.style.background = '#e74c3c';
                }
            }
            
            updateBossHealthBar() {
                if (!this.boss) return;
                const healthPercentage = (this.boss.health / this.boss.maxHealth) * 100;
                this.bossHealthBarElement.style.width = healthPercentage + '%';
            }

            createProjectile() {
                const randomData = this.projectileData[Math.floor(Math.random() * this.projectileData.length)];
                let x, y;
                if (randomData.type === 'aoe') {
                    x = Math.random() * this.canvas.width;
                    y = Math.random() * this.canvas.height;
                } else {
                    x = Math.random() * this.canvas.width;
                    y = -50;
                }
                this.projectiles.push(new Projectile(this, x, y, randomData));
            }
            
            spawnBoss() {
                this.boss = new Boss(this, this.canvas.width / 2, -100, 50, this.BOSS_HEALTH, 2);
                this.isBossFight = true;
                this.bossHealthContainer.style.display = 'block';
                this.playSound(150, 0.5, 0.5);
            }
            
            destroyBoss() {
                for (let j = 0; j < 100; j++) {
                    this.particles.push(new Particle(this, this.boss.x, this.boss.y, '#e74c3c'));
                }
                this.shakeScreen();
                this.score += 5000;
                this.boss = null;
                this.isBossFight = false;
                this.bossHealthContainer.style.display = 'none';
                this.projectiles = [];
                this.playSound(120, 1, 0.8, 'sawtooth');
            }

            createCollectable() {
                const randomData = this.collectableData[Math.floor(Math.random() * this.collectableData.length)];
                const x = Math.random() * this.canvas.width;
                const y = Math.random() * this.canvas.height;
                this.collectables.push(new Collectable(this, x, y, randomData));
            }
            
            createPlayerParticles() {
                if (Math.random() > 0.8) {
                    this.playerParticles.push(new Particle(this, this.player.x, this.player.y, 'rgba(255, 255, 255, 0.5)'));
                }
            }

            initStars() {
                this.stars = [];
                for (let i = 0; i < 100; i++) {
                    this.stars.push(new Star(this));
                }
            }
        }

        const game = new Game();
    </script>
</body>
</html>
